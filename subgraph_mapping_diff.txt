diff --git a/clmsr-subgraph/src/clmsr-market-core.ts b/clmsr-subgraph/src/clmsr-market-core.ts
index 46f444c..e1d1b25 100644
--- a/clmsr-subgraph/src/clmsr-market-core.ts
+++ b/clmsr-subgraph/src/clmsr-market-core.ts
@@ -18,9 +18,9 @@ import {
   PositionSettled as PositionSettledEvent,
   MarketCreated as MarketCreatedEvent,
   MarketSettled as MarketSettledEvent,
+  MarketSettlementValueSubmitted as MarketSettlementValueSubmittedEvent,
   RangeFactorApplied as RangeFactorAppliedEvent,
 } from "../generated/CLMSRMarketCore/CLMSRMarketCore";
-import { PointsGranted } from "../generated/PointsGranterUpgradeable/PointsGranterUpgradeable";
 import {
   PositionOpened,
   PositionIncreased,
@@ -28,8 +28,8 @@ import {
   PositionClosed,
   PositionClaimed,
   PositionSettled,
-  MarketCreated,
   MarketSettled,
+  MarketSettlementValueSubmitted,
   RangeFactorApplied,
   Market,
   UserPosition,
@@ -190,6 +190,14 @@ function calculateDisplayPrice(cost: BigInt, quantity: BigInt): BigDecimal {
 
 // ============= 기존 헬퍼 함수들 =============
 
+// Constants for WAD calculations
+const WAD = BigInt.fromString("1000000000000000000");
+
+// Helper function: safe WAD multiplication with floor division
+function wMulDown(a: BigInt, b: BigInt): BigInt {
+  return a.times(b).div(WAD);
+}
+
 // Helper function to update bin volumes for given tick range
 function updateBinVolumes(
   marketId: BigInt,
@@ -250,24 +258,6 @@ function updateBinVolumes(
 }
 
 export function handleMarketCreated(event: MarketCreatedEvent): void {
-  let entity = new MarketCreated(
-    event.transaction.hash.concatI32(event.logIndex.toI32())
-  );
-  entity.marketId = event.params.marketId;
-  entity.minTick = event.params.minTick;
-  entity.maxTick = event.params.maxTick;
-  entity.tickSpacing = event.params.tickSpacing;
-  entity.startTimestamp = event.params.startTimestamp;
-  entity.endTimestamp = event.params.endTimestamp;
-  entity.numBins = event.params.numBins;
-  entity.liquidityParameter = event.params.liquidityParameter;
-
-  entity.blockNumber = event.block.number;
-  entity.blockTimestamp = event.block.timestamp;
-  entity.transactionHash = event.transaction.hash;
-
-  entity.save();
-
   let marketIdStr = buildMarketId(event.params.marketId);
   let market = new Market(marketIdStr);
   market.marketId = event.params.marketId;
@@ -279,6 +269,8 @@ export function handleMarketCreated(event: MarketCreatedEvent): void {
   market.numBins = event.params.numBins;
   market.liquidityParameter = event.params.liquidityParameter;
   market.isSettled = false;
+  market.settlementValue = null;
+  market.settlementTick = null;
   market.lastUpdated = event.block.timestamp;
   market.save();
 
@@ -352,6 +344,32 @@ export function handleMarketSettled(event: MarketSettledEvent): void {
   let market = Market.load(buildMarketId(event.params.marketId))!;
   market.isSettled = true;
   market.settlementTick = event.params.settlementTick;
+  // Convert settlementTick to 6 decimal format for consistency
+  market.settlementValue = event.params.settlementTick.times(
+    BigInt.fromI32(1_000_000)
+  );
+  market.lastUpdated = event.block.timestamp;
+  market.save();
+}
+
+export function handleMarketSettlementValueSubmitted(
+  event: MarketSettlementValueSubmittedEvent
+): void {
+  let entity = new MarketSettlementValueSubmitted(
+    event.transaction.hash.concatI32(event.logIndex.toI32())
+  );
+  entity.marketId = event.params.marketId;
+  entity.settlementValue = event.params.settlementValue;
+
+  entity.blockNumber = event.block.number;
+  entity.blockTimestamp = event.block.timestamp;
+  entity.transactionHash = event.transaction.hash;
+
+  entity.save();
+
+  // Update market with settlement value (6 decimals)
+  let market = Market.load(buildMarketId(event.params.marketId))!;
+  market.settlementValue = event.params.settlementValue;
   market.lastUpdated = event.block.timestamp;
   market.save();
 }
@@ -1042,10 +1060,21 @@ export function handleRangeFactorApplied(event: RangeFactorAppliedEvent): void {
 
   entity.save();
 
-  let market = Market.load(buildMarketId(event.params.marketId))!;
+  let market = Market.load(buildMarketId(event.params.marketId));
+  if (market == null) {
+    // Market not found - skip this event
+    return;
+  }
   market.lastUpdated = event.block.timestamp;
   market.save();
 
+  let distribution = MarketDistribution.load(market.id);
+  if (distribution == null) {
+    // Distribution not found - skip this event
+    return;
+  }
+
+  // Convert tick range to bin indices (upper exclusive)
   let lowerBinIndex = event.params.lo
     .minus(market.minTick)
     .div(market.tickSpacing)
@@ -1053,19 +1082,22 @@ export function handleRangeFactorApplied(event: RangeFactorAppliedEvent): void {
   let upperBinIndex =
     event.params.hi.minus(market.minTick).div(market.tickSpacing).toI32() - 1;
 
+  // Contract ensures valid ranges - no silent clamping needed
+  // Invalid ranges would have been reverted before event emission
+
+  // (C) Apply factor to each bin (leaf model - contract equivalent)
   for (let binIndex = lowerBinIndex; binIndex <= upperBinIndex; binIndex++) {
     let binState = BinState.load(
       buildBinStateId(event.params.marketId, binIndex)
     )!;
-    binState.currentFactor = binState.currentFactor
-      .times(event.params.factor)
-      .div(BigInt.fromString("1000000000000000000"));
+    let updated = wMulDown(binState.currentFactor, event.params.factor);
+    binState.currentFactor = updated;
     binState.lastUpdated = event.block.timestamp;
     binState.updateCount = binState.updateCount.plus(BigInt.fromI32(1));
     binState.save();
   }
 
-  let distribution = MarketDistribution.load(market.id)!;
+  // (F) Recompute statistics and arrays (full bin traversal once)
   let totalSumWad = BigInt.fromI32(0);
   let minFactorWad = BigInt.fromString("999999999999999999999999999999");
   let maxFactorWad = BigInt.fromI32(0);
@@ -1087,47 +1119,14 @@ export function handleRangeFactorApplied(event: RangeFactorAppliedEvent): void {
     binVolumes.push(binState.totalVolume.toString());
   }
 
-  let avgFactorWad = totalSumWad.div(market.numBins);
-
+  // (G) Use actual leaf sum as truth (contract leaf model equivalent)
   distribution.totalSum = totalSumWad;
   distribution.minFactor = minFactorWad;
   distribution.maxFactor = maxFactorWad;
-  distribution.avgFactor = avgFactorWad;
+  distribution.avgFactor = distribution.totalSum.div(market.numBins);
   distribution.binFactors = binFactorsWad;
   distribution.binVolumes = binVolumes;
   distribution.version = distribution.version.plus(BigInt.fromI32(1));
   distribution.lastSnapshotAt = event.block.timestamp;
   distribution.save();
 }
-
-function mapReason(code: i32): string {
-  if (code == 1) return "ACTIVITY";
-  if (code == 2) return "PERFORMANCE";
-  if (code == 3) return "RISK_BONUS";
-  return "MANUAL";
-}
-
-/** Handle manual grant from PointsGranter */
-export function handlePointsGranted(e: PointsGranted): void {
-  const ts = e.params.contextTs.notEqual(BigInt.zero())
-    ? e.params.contextTs
-    : e.block.timestamp;
-
-  const reason = mapReason(e.params.reason as i32);
-  const userStats = getOrCreateUserStats(e.params.user);
-
-  // 포인트 적립
-  userStats.totalPoints = userStats.totalPoints.plus(e.params.amount);
-  if (reason == "ACTIVITY") {
-    userStats.activityPoints = userStats.activityPoints.plus(e.params.amount);
-  } else if (reason == "PERFORMANCE") {
-    userStats.performancePoints = userStats.performancePoints.plus(
-      e.params.amount
-    );
-  } else if (reason == "RISK_BONUS") {
-    userStats.riskBonusPoints = userStats.riskBonusPoints.plus(e.params.amount);
-  }
-  userStats.save();
-
-  recordEventHistory(e, userStats.user, e.params.amount, reason, ts);
-}
