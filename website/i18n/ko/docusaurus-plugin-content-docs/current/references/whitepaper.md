# Signals CLMSR 백서

Signals 백서는 연속 LMSR(CLMSR)을 어떻게 구현하고 운영하는지를 공식적으로 정의한 문서입니다. 확률이 어떻게 계산되는지, $\alpha \ln n$ 손실 상한이 왜 유지되는지, Solidity 구현이 어떤 제약과 라운딩 규칙을 따르는지를 모두 이 백서에서 확인할 수 있습니다. 프로토콜을 점검하거나 통합 제품을 설계할 때 언제든 참고하세요.

## 다운로드 및 버전

최신 버전은 [Signals CLMSR Whitepaper (PDF)](/whitepaper.pdf)에 항상 게시합니다. 현재 공개된 `v1.0`은 1.1.0 릴리즈 단계의 컨트랙트와 일치하며, 메커니즘이 수정될 경우 백서 버전과 [변경 로그](../changelog/index.md)도 함께 갱신됩니다.

## 백서가 다루는 내용

1. **메커니즘 유도** – 고전 LMSR에서 출발해 Signals가 사용하는 연속 잠재함수를 도출합니다. $\alpha$가 마켓메이커 손실을 $\alpha \ln n$으로 제한하는 구조와 모든 밴드가 하나의 볼록 함수 위에 놓여 있는 이유를 증명합니다.
2. **Outcome 그리드 구성** – `OutcomeSpec = (L, U, s, d)`를 형식적으로 정의하고, 반개방 구간이 확률 정규화를 어떻게 보장하는지 설명합니다. 오라클 값이 경계에 놓일 때도 결과가 안정적으로 기록되는 과정을 볼 수 있습니다.
3. **Lazy Multiplicative Segment Tree** – 수백만 개 틱을 저장하는 데이터 구조의 불변식과 지연 업데이트 방식을 분석합니다. 지연된 가중치가 언제 플러시되고, 배치 한도를 왜 제한하는지도 여기서 다룹니다.
4. **라운딩 규율** – 비용을 올림, 수익을 내림 처리하는 이유와 허용 가능한 더스트 범위를 정량화합니다. 향후 구현 예정인 매도·청구 라운딩 업데이트도 사전 정의돼 있습니다.

## 활용 가이드

- **컨트랙트와 함께 읽기**: `contracts/core/CLMSRMarketCore.sol`과 `contracts/libraries/LazyMulSegmentTree.sol`을 같이 열어두고 각 수식이 코드에서 어떻게 나타나는지 비교하세요. 최소 주문 크기처럼 아직 정책으로만 존재하는 항목은 “Implementation Status” 표에서 확인할 수 있습니다.
- **감사·보안 리뷰**: 백서의 증명과 [보안 & 테스트 개요](../security/audits.md)에 정리된 운영 보증을 함께 보면서 이론적 경계와 런타임 체크가 어떻게 맞물리는지 점검하세요.
- **리서치·프로덕트 작업**: 대시보드나 리스크 리포트에서 확률을 계산할 때 백서의 기호와 공식을 사용하면 온체인 값, SDK, 문서가 모두 동일한 표현을 쓰게 됩니다.

## 함께 보면 좋은 자료

- [메커니즘 개요](../mechanism/overview.md)는 백서 내용을 서술형으로 풀어낸 가이드입니다.
- [비용 & 라운딩](../mechanism/cost-rounding.md)과 [안전 파라미터](../mechanism/safety-parameters.md)는 실 구현과 백서 사이의 차이를 지속적으로 업데이트합니다.
- [서브그래프 API](../api/subgraph.md)는 백서에서 사용한 변수들을 온체인 데이터로 어떻게 조회할 수 있는지 안내합니다.

Signals의 CLMSR 구현을 인용하거나 확장할 때는 이 백서를 1차 출처로 사용하세요. 모든 범위 거래의 수학적 근거가 여기에 정리돼 있습니다.
