# 비용 함수와 라운딩

> 참고: Signals CLMSR 백서 v1.0 -- §4-§8

이 장은 시그널스가 거래 가격을 어떻게 책정하고 왜 라운딩 규칙이 중요한지 설명합니다. 코드를 감사한다면 `LazyMulSegmentTree.sol`, `FixedPointMath.sol`을 함께 열어 보세요. 온체인 구현은 여기에서 소개하는 구조와 동일하게 맞춰져 있습니다.

## 모든 빈을 하나의 잠재함수로 관리

CLMSR은 틱 보유량 $q_b$ 전부를 단일 볼록 잠재함수에 담습니다.

$$
C(q) = \alpha \ln \left( \sum_b e^{q_b / \alpha} \right)
$$

유동성 파라미터 $\alpha$는 WAD 값으로 저장되고, 지수 가중치 $w_b = e^{q_b/\alpha}$가 기울기를 결정합니다. 가격은

$$
p_b = \frac{w_b}{\sum_j w_j}
$$

으로 계산되어 누적 확률이 항상 1이 되도록 보장합니다. 범위를 $\delta$만큼 매수하면 해당 범위에 포함된 빈의 가중치가 $\varphi = e^{\delta/\alpha}$배가 되고, 비용은 잠재함수 변화량으로 계산됩니다.

$$
\Delta C = \alpha \ln\left(\frac{\Sigma_\text{after}}{\Sigma_\text{before}}\right)
$$

판매는 $\delta$에 부호만 반대로 적용한 동일한 식을 사용합니다.

## 지수 계산을 안전하게 유지

지수 함수는 PRB-Math 한계를 지키기 위해 청크 단위로 평가합니다. 구현 상 각 입력은 `MAX_EXP_INPUT_WAD = 1e18`을 넘지 않도록 제한되며, 이는 사실상 `(chunk/alpha) <= 1`을 만족하게 만듭니다. lazy segment tree가 큰 거래를 자동으로 나누기 때문에 단일 호출이 정밀도나 가스 한도를 초과하지 않습니다.

## Lazy 세그먼트 트리 구현

CLMSR은 모든 지수 가중치를 희소한 지연 곱 세그먼트 트리에 보관해 매 거래마다 모든 빈을 직접 만지지 않고도 정확한 가격을 유지합니다.

- 리프는 단일 빈의 가중치를 추적하며 기본값은 1(빈 포지션의 가중치)입니다. 내부 노드는 자식 합계를 캐시해 업데이트 이후에도 한 슬롯만 읽어서 $\\sum_j w_j$ 값을 확보합니다.
- `applyRangeFactor`는 목표 범위의 리프 전체를 곱하지만 경로상의 노드만 방문합니다. 지연 전파 덕분에 시장이 수백 개의 빈을 운영해도 쓰기와 읽기 모두 $O(\log n)$ 복잡도를 유지합니다.
- 대기 중인 승수는 플러시 임계치까지 누적되며, 임계치를 넘으면 트리가 승수를 두 자식에게 내려보내고 부모 노드를 재설정해 수치 오차가 누적되지 않도록 합니다.
- 루트 합계는 변경이 일어날 때마다 갱신되어 가격 계산의 분모가 됩니다. `CLMSRMarketCore`는 이 캐시 값을 사용해 견적과 이벤트를 즉시 산출합니다.
- 모든 곱셈은 `wMulNearest`를 사용해 최근접(동일 시 올림) 라운딩으로 처리되고, pendingFactor 조합에도 같은 규칙이 적용되어 하향 편향 없이 뷰/갱신 경로가 일관된 결과를 유지합니다.

대규모 거래도 `MAX_EXP_INPUT_WAD` 보호를 따릅니다. `CLMSRMarketCore`가 거래를 안전한 청크로 나눠 각 트리 업데이트가 PRB-Math에 허용된 지수만 전달하도록 합니다.

비용 견적 단계에서는 코어 컨트랙트가 캐시된 루트(Σ_before)를 읽고 `getRangeSum`으로 영향을 받는 범위를 좁힌 뒤, `_calculateTradeCostInternal`과 `_calculateSellProceeds`가 청크별로 합계를 갱신해 로그가 항상 최신 상태를 반영하도록 합니다. 거래가 승인되면 `_applyFactorChunked`가 동일한 청크 분할 로직으로 트리를 갱신하고, 멀티플라이어마다 `RangeFactorApplied` 이벤트를 발행합니다. 이 흐름 덕분에 백서에서 요구하는 것처럼 범위 전체 가격이 동시에 갱신되면서도 온체인 연산량은 빈 수에 대해 준선형으로 유지됩니다.

결제 토큰이 6자리 소수를 사용하기 때문에 `_maxSafeChunkQuantity`가 모든 청크를 `1e12` WAD(마이크로 USDC 한 단위)에 맞춰 정규화합니다. 코어는 청크별 견적을 마이크로 단위로 올림한 뒤 합산하여, 동일한 거래를 순차적으로 수행했을 때와 비교해 최대 `(청크 수 − 1)` 마이크로 USDC 이내의 오차 범위에 들어오도록 유지합니다. 다양한 α·수량 조합을 대상으로 한 단위 테스트가 이 라운딩 파리티를 고정하고 있습니다.

## 최근접 라운딩 정책

편향을 제거하기 위해 라운딩 규칙을 대칭형으로 전환했습니다. 최소 비용 보장은 유지하면서 매수·매도 모두 동일한 기준으로 반올림합니다.

| 액션 | 라운딩 방식 | 사용 함수 |
| --- | --- | --- |
| 매수 / 증가 | 최근접 반올림(동일 시 올림) + 최소 1 μUSDC 보장 | `fromWadNearestMin1` |
| 매도 / 감소 / 종료 | 최근접 반올림(동일 시 올림) | `fromWadNearest` |
| 정산 지급 | 포지션 수량(이미 6자리 소수) | — |

**구현 현황:** Sprint R에서 코어·SDK·운영 스크립트가 순차적으로 최근접 정책으로 통합되고 있습니다. 매수 견적은 항상 최소 1 μUSDC 이상으로 생각하고, 매도/종료 시에는 WAD 계산 대비 ±1 μUSDC 이내의 차이를 허용하면 됩니다.

## 최소 비용 보장

매수 시 올림과 최소 주문 크기 $\delta_{\min}$ 덕분에 모든 거래는 최소 1 마이크로 SUSD 이상을 차감합니다. 공격자는 무료 더스트 포지션을 남겨둘 수 없고, 감사자는 모든 포지션에 실질적인 위험이 걸려 있다고 가정할 수 있습니다.

> **구현 메모:** `fromWadRoundUp`은 $10^{12}$로 나누기 전에 1을 빼기 때문에 `type(uint256).max` 입력도 0으로 감기지 않고 양의 마이크로 단위로 반올림됩니다. 이는 극단적인 WAD 값에서도 무상 공격을 막도록 보강한 조치입니다.

## 최근접 라운딩 헬퍼(전환 단계)

Signals는 Market #64에서 관측된 누적 편향을 제거하기 위해 대칭형 최근접 라운딩 정책으로 전환하고 있습니다. 온체인·SDK·서브그래프가 동시에 움직일 수 있도록 먼저 Solidity 헬퍼를 도입했습니다.

- `fromWadNearest`는 WAD 값을 6자리 소수로 변환할 때 가까운 정수(동일 시 올림)로 반올림합니다.
- `fromWadNearestMin1`는 입력이 0이 아닌 경우 최소 1 마이크로 단위를 보장합니다.
- `wMulNearest`는 PRB `mulDiv`와 동일하지만 결과를 가장 가까운 WAD로 반올림합니다.

전환 기간 동안 이 헬퍼들은 기존 `fromWadRoundUp`과 함께 존재하며, 모든 호출부가 최근접 정책으로 전환되면 비대칭 헬퍼는 제거될 예정입니다.

## 코드에서 확인할 위치

- `LazyMulSegmentTree.sol`이 청크 분할과 지수 가중치 업데이트를 구현합니다.
- `FixedPointMath.sol`은 `fromWadRoundUp`, `fromWadNearest`, `fromWadNearestMin1`, `wMulNearest` 등 라운딩 헬퍼를 제공합니다.
- 단위 테스트가 라운딩 방향과 청크 분할 에지 케이스를 검증합니다.

이 루틴을 안전하게 유지하는 상수는 [안전 한계와 파라미터](safety-parameters.md) 장에서 이어서 다룹니다.
