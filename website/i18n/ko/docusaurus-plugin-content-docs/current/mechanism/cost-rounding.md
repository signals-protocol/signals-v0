# 비용 함수와 라운딩

> 참고: Signals CLMSR 백서 v1.0 -- §4-§8

이 장은 시그널스가 거래 가격을 어떻게 책정하고 왜 라운딩 규칙이 중요한지 설명합니다. 코드를 감사한다면 `LazyMulSegmentTree.sol`, `FixedPointMath.sol`을 함께 열어 보세요. 온체인 구현은 여기에서 소개하는 구조와 동일하게 맞춰져 있습니다.

## 모든 밴드를 하나의 잠재함수로 관리

CLMSR은 틱 보유량 $q_b$ 전부를 단일 볼록 잠재함수에 담습니다.

$$
C(q) = \alpha \ln \left( \sum_b e^{q_b / \alpha} \right)
$$

유동성 파라미터 $\alpha$는 WAD 값으로 저장되고, 지수 가중치 $w_b = e^{q_b/\alpha}$가 기울기를 결정합니다. 가격은

$$
p_b = \frac{w_b}{\sum_j w_j}
$$

으로 계산되어 누적 확률이 항상 1이 되도록 보장합니다. 밴드를 $\delta$만큼 매수하면 해당 밴드 내부의 가중치가 $\varphi = e^{\delta/\alpha}$배가 되고, 비용은 잠재함수 변화량으로 계산됩니다.

$$
\Delta C = \alpha \ln\left(\frac{\Sigma_\text{after}}{\Sigma_\text{before}}\right)
$$

판매는 $\delta$에 부호만 반대로 적용한 동일한 식을 사용합니다.

## 지수 계산을 안전하게 유지

지수 함수는 PRB-Math 한계를 지키기 위해 청크 단위로 평가합니다. 구현 상 각 입력은 `MAX_EXP_INPUT_WAD = 1e18`을 넘지 않도록 제한되며, 이는 사실상 `(chunk/alpha) <= 1`을 만족하게 만듭니다. lazy segment tree가 큰 거래를 자동으로 나누기 때문에 단일 호출이 정밀도나 가스 한도를 초과하지 않습니다.

## 비대칭 라운딩

백서는 액션별로 한 번만 변환을 허용하며 방향을 고정해 “공짜 거래” 가능성을 닫습니다.

| 액션 | 라운딩 방향 | 사용 함수 |
| --- | --- | --- |
| 매수 / 증가 | **올림** | `fromWadRoundUp` |
| 매도 / 감소 / 종료 | **내림** | `fromWadFloor` |
| 정산 지급 | **내림** | `fromWadFloor` |

**구현 현황:** 매수는 이미 올림을 사용합니다. 판매와 지급은 현재 프로덕션 컨트랙트에서 아직 올림을 적용하지만, 백서와 일치하도록 내림으로 바꿀 예정입니다. 업데이트 이전까지는 실제 수령액이 향후 기대치보다 약간 높을 수 있으니 대시보드에서 안내해야 합니다.

## 최소 비용 보장

매수 시 올림과 최소 주문 크기 $\delta_{\min}$ 덕분에 모든 거래는 최소 1 마이크로 SUSD 이상을 차감합니다. 공격자는 무료 더스트 포지션을 남겨둘 수 없고, 감사자는 모든 포지션에 실질적인 위험이 걸려 있다고 가정할 수 있습니다.

## 코드에서 확인할 위치

- `LazyMulSegmentTree.sol`이 청크 분할과 지수 가중치 업데이트를 구현합니다.
- `FixedPointMath.sol`에 라운딩 헬퍼(`fromWadRoundUp`, `fromWadFloor`)가 있습니다.
- `test/unit/libraries/**` 테스트가 라운딩 방향과 청크 분할 에지 케이스를 검증합니다.

이 루틴을 안전하게 유지하는 상수는 [안전 한계와 파라미터](safety-parameters.md) 장에서 이어서 다룹니다.
